[toc]

内容参考[C Standard Library Reference Tutorial](https://www.tutorialspoint.com/c_standard_library/index.htm)。

## *memset*

#### *语法*

``` c
void *memset(void *str, int c, size_t n)
```

#### *参数*

- *str* ：指向内存区域首地址
- *c* ：向内存区域填充的值（填充前会将 *c* 的数据类型从 *int* 型转变为无符号 *char* 型）。
-  *n* ：内存区域的大小。

#### *解释*

*memset* 依据 *str* 指针找到用户指定的内存区域，然后以字节为单位将该内存区域的每个字节填充为 *c* 值，总共填充 *n* 个字节。

有一个隐含的问题是， *c* 是 *int* 型的 *4* 字节数据，而 *memset* 是以单字节为单位进行数据填充。因此实际上，在进行数据填充前 *c* 的数据类型会从 *int* 型转化为 *unsigned char* 型。 

#### *用法*

1. 对整数型数组的所有成员统一赋值为0或者-1。

    ```
    memset(array, 0, sizeof(array));
    ```
    
    该用法只能赋值 *0* 或者 *-1* ，赋值任何其他数据都无效。这里假设程序员想向一个 *int* 型数组的所有成员赋值为 *1* ：

     *int* 型的 *1* 转化为 *unsigned char* 型的数据后，二进制表示为`0000 0001`。接着该数组内存区域的所有字节都将被 *memset* 填充为`0000 0001`。这时，实际上，每个成员的值都被统一赋值为 *4* 个字节的`0000 0001`，而不是 *3* 个字节的`0000 0000`和一个字节的`0000 0001`，因此无效赋值为 *1* 。其他数据类似。

    而 *0* 和 *-1* 有效的原因： *int* 型的 *0* 转化为 *unsigned char* 型数据后，二进制表示为`0000 0000`，进行字节数据填充后，每个成员的值都被统一赋值为 *4* 个字节的`0000 0000`，为 *0* ； *int* 型的 *-1* 转化为 *unsigned char* 型数据后，二进制表示为`1111 1111`[^1]，进行字节数据填充后，每个成员的值都被统一赋值为 *4* 个字节的`1111 1111`，为 *-1* 。 

2. 对字符型数字的所有成员统一赋值为一个字符。

    ```
    memset(array, 'A', sizeof(array));
    ```

[^1]: *-1* 的补码形式
